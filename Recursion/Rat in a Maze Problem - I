    bool issafe(int newx,int newy,int n,vector<vector<bool>>&visited,vector < vector < int >> & arr)
{
	if((newx>=0 && newx<n ) && (newy>=0 && newy<n ) && 
	   visited[newx][newy]!=1  && arr[newx][newy]==1)
		return true;
	else
	return false;
}

void solve(int x,int y,vector < vector < int >> & arr,int n,vector<string>&ans,vector<vector<bool>>&visited,string path)
{
	if(x==n-1 && y==n-1){
		ans.push_back(path);
		return;
	}
	// down
	if(issafe(x+1,y,n,visited,arr))
	{
		visited[x][y]=1;
		solve(x+1,y,arr,n,ans,visited,path+'D');
		visited[x][y]=0;
	}
	// left
	if(issafe(x,y-1,n,visited,arr))
	{
		visited[x][y]=1;
		solve(x,y-1,arr,n,ans,visited,path+'L');
		visited[x][y]=0;
	}
	// right
	if(issafe(x,y+1,n,visited,arr))
	{
		visited[x][y]=1;
		solve(x,y+1,arr,n,ans,visited,path+'R');
		visited[x][y]=0;
	}
	// up
	if(issafe(x-1,y,n,visited,arr))
	{
		visited[x][y]=1;
		solve(x-1,y,arr,n,ans,visited,path+'U');
		visited[x][y]=0;
	}
}
    vector<string> findPath(vector<vector<int>> &arr, int n) {
        // Your code goes here
        vector<string>ans;
	vector<vector<bool>>visited(n,vector<bool>(n,0));
	if(arr[0][0]==0)
		return ans;
	
	string path="";
	solve(0,0,arr,n,ans,visited,path);
	return ans;
    }
